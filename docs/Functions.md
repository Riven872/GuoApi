## 开放 API 平台

### 一、架构

#### 1、业务流程

1. 管理员
    1. 发布接口、下线接口、管理接口、统计接口调用次数。
2. 用户
    1. 浏览接口、调用接口，调用接口时，先经过 API 网关进行鉴权、请求分发，然后经过自定义的 SDK 对第三方接口进行 http 远程调用。

#### 2、目录模块

1. api-backend：主模块，处理基本的用户请求，如登录、管理接口、使用 SDK 调用第三方接口等
2. api-common：定义公共的实体、VO、DTO、自定义异常类、自定义返回类、通用返回对象、枚举错误码
3. api-gateway：API 网关，拦截向第三方的请求，进行负载均衡、鉴权、调用次数的扣减
    1. todo 因为前端请求的是 api-backend 主模块，因此目前只在主模块中配置了跨域，实质应该在应用网关层设置全局跨域或考虑使用 Nginx 配置跨域
4. api-rpc：定义 Dubbo 远程调用的提供方接口，交由对应的模块去实现
5. api-test：自定义测试第三方接口，用来跑通整个流程

#### 3、数据库表

1. user（用户信息表）：用户的基本信息，如账号、密码、昵称、头像、AccessKey、SecretKey、权限等
2. interface_info（接口信息表）：接口的基本信息，如接口地址、调用方法、请求头、请求参数、响应头、接口状态、上传用户 id 等
3. user_interface_info（用户接口信息中间表）：记录用户调用接口的信息，如调用次数、剩余调用次数等



### 二、功能模块

#### 1、用户模块

1. 注册
    1. 使用 `synchronized (userAccount.intern())` 以及查库逻辑来保证并发时用户名的唯一性，并将密码加密加盐存放进数据库，并随机生成 AccessKey 和 SecretKey 加密加盐存进数据库。
2. 登录
    1. 将用户输入的密码同样的加密加盐，与数据库中存放的密码进行比对，登录成功则存放在 Session 中。
    2. todo 微服务下应该将用户信息放在 Redis 中
3. 获取登录用户
    1. 从 Session 中获取
    2. todo 从 Redis 中获取用户的信息
4. 用户注销
    1. 移除 Session 中用户的登录态
    2. todo 从 Redis 中移除用户信息
5. 用户的基本 CRUD
    1. 根据条件查询用户、分页查询、修改用户信息、删除用户等
6. todo
    1. 新增手机号注册和登录，使用腾讯云 SMS 发送短信发送验证码
    2. 新增 GitHub 第三方接入登录
    3. 忘记密码待定

#### 2、接口信息模块

1. 接口的基本 CRUD
    1. 新增接口（不需要进行连通性的测试，因为还有一步上线）、修改接口、删除接口
2. 发布接口
    1. 发布时，需要调用一次接口，如果可以连通则正常上线
3. 下线接口
    1. 直接修改接口状态
4. 调用指定的第三方接口
    1. 判断接口是否存在且接口是否开启，并使用 SDK 去调用指定的第三方接口，鉴权交给应用网关去做处理

#### 3、用户接口关系模块

1. 基本的 CRUD
    1. 略
2. 增加调用次数
    1. 指定用户指定接口的调用次数 +1
    2. todo 在应用网关层调用成功后，可以新开启一个线程将调用成功的信息发送到 MQ 中，消费者进行调用次数 +1 的操作

#### 4、SDK 模块（第三方接口模块）

1. 提供准确的第三方调用地址，但不对外暴露，在调用时，增加应用网关地址的前缀，直接请求网关
2. todo 应用网关也注册到了 Nacos，因此可以考虑使用增加网关的应用名称前缀，而非具体的 ip
3. 网关经过断言，通过负载转发到 api-test 模块，也即第三方接口处
4. 使用 SDK 的模块需要传入 AccessKey 和 SecretKey
5. SDK 提供加密生成签名，并添加请求头，将必须信息放入，以生成提供签名的比对

#### 5、业务网关模块

1. 通过断言拦截特定规则的请求，负载转发到第三方接口所在的服务
2. 将请求头中的参数取出来生成签名，进行比对。鉴权失败或调用失败时，标记 403 状态码并进行返回



### 三、优化部分

#### 1、Redis + Session 完成服务器间的 Session 共享（实际是 Redis 单独处理）

1. 在主启动类上添加注解 `@EnableRedisHttpSession`，并在该注解内设置过期时间、自定义分组 key 等，也可以在 yml 中设置过期时间和自定义分组 key 值等，效果与注解相同，若同时配置则注解生效

2. 需要手动设置 Session 专用的 Redis 序列化器，将值转换为 Json 格式

    ```java
    @Bean
    public RedisSerializer<Object> springSessionDefaultRedisSerializer() {
        return new GenericJackson2JsonRedisSerializer();
    }
    ```

3. 采用该方法会导致一些额外的 session 信息不会在用户注销时及时清除，因此采用手动 Redis 的方法来完成单点登录

    1. 用户登录时，将信息放到 Redis 中，并设置过期时间
    2. 新增拦截器，每次请求时检查 Redis 中是否有用户信息，如果有则续期，无则放行
    3. todo 其中设置键值时，随机生成令牌，并方法请求头中，取值时，使用请求头中的令牌生成 key，（这个明天前端实现，必须实现，可以用来区别登录的不同用户）



### 四、部署

##### 1、部署后端

1. 所有有主启动类的模块进行 Package 打包，打包之前，将相应的依赖也提前 Package
2. todo 使用 Maven 从 GitHub 拉取并一键部署